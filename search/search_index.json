{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pocketdock","text":"<p>Portable, offline-first container sandboxes for LLM agents and dev workflows.</p> <p>pocketdock is a Python SDK and CLI that talks directly to Podman or Docker over its Unix socket. No cloud. No API keys. No external dependencies for the core SDK.</p>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>LLM agent code execution \u2014 run untrusted code in isolated sandboxes with resource limits</li> <li>Code evaluation pipelines \u2014 evaluate student/candidate code safely with timeouts and output caps</li> <li>Embedded development \u2014 C/C++ cross-compilation for ARM, ESP32, Arduino inside containers</li> <li>Reproducible dev environments \u2014 disposable sandboxes with pre-baked toolchains</li> <li>CI/CD building blocks \u2014 lightweight, scriptable container orchestration</li> </ul>"},{"location":"#feature-highlights","title":"Feature Highlights","text":"Feature Description Three execution modes Blocking, streaming, and detached with ring buffer File operations Read, write, list, push, pull between host and container Persistent sessions Long-lived shells with state (cwd, env vars, history) Resource limits Memory caps and CPU throttling per container Persistence Stop/resume containers, snapshot to images, volume mounts Project management <code>.pocketdock/</code> directories with config, logging, health checks Image profiles Four pre-baked Dockerfiles: minimal, dev, agent, embedded Full CLI 21 commands for lifecycle, file ops, and project management Async-first Sync facade over async core \u2014 use either API Callbacks Register handlers for stdout, stderr, and exit events"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from pocketdock import create_new_container\n\nwith create_new_container() as c:\n    # Run a command\n    result = c.run(\"echo hello\")\n    print(result.stdout)  # \"hello\\n\"\n    print(result.ok)      # True\n\n    # Run Python code\n    result = c.run(\"print(2 + 2)\", lang=\"python\")\n    print(result.stdout)  # \"4\\n\"\n\n    # Read/write files\n    c.write_file(\"/tmp/data.txt\", \"hello from host\")\n    data = c.read_file(\"/tmp/data.txt\")\n# Container is automatically stopped and removed\n</code></pre>"},{"location":"#install","title":"Install","text":"SDK onlySDK + CLI <pre><code>pip install pocketdock\n</code></pre> <pre><code>pip install pocketdock[cli]\n</code></pre> <p>Requires Podman (recommended) or Docker.</p>"},{"location":"#whats-next","title":"What's Next?","text":"<ul> <li>Quickstart \u2014 build an image and run your first container in under a minute</li> <li>User Guide \u2014 deep dive into containers, commands, files, sessions, and more</li> <li>CLI Reference \u2014 all 21 commands with examples</li> <li>API Reference \u2014 full SDK reference with type signatures</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>See the full changelog on GitHub: CHANGELOG.md</p>"},{"location":"cli/","title":"CLI Reference","text":"<p>pocketdock includes a full CLI for managing containers from the terminal.</p>"},{"location":"cli/#install","title":"Install","text":"<pre><code>pip install pocketdock[cli]\n</code></pre>"},{"location":"cli/#global-options","title":"Global Options","text":"Option Env Var Description <code>--socket PATH</code> <code>POCKETDOCK_SOCKET</code> Container engine socket path <code>--verbose / -v</code> \u2014 Enable verbose output <code>--version</code> \u2014 Show version and exit <code>--help</code> \u2014 Show help and exit"},{"location":"cli/#project-commands","title":"Project Commands","text":""},{"location":"cli/#init","title":"<code>init</code>","text":"<p>Initialize a <code>.pocketdock/</code> project directory.</p> <pre><code>pocketdock init [PATH]\n</code></pre> Option Description <code>PATH</code> Directory to initialize (default: current directory)"},{"location":"cli/#status","title":"<code>status</code>","text":"<p>Show project summary and container states.</p> <pre><code>pocketdock status [--json]\n</code></pre>"},{"location":"cli/#doctor","title":"<code>doctor</code>","text":"<p>Diagnose orphaned containers and stale instance directories.</p> <pre><code>pocketdock doctor [--json]\n</code></pre>"},{"location":"cli/#logs","title":"<code>logs</code>","text":"<p>View command history for the project.</p> <pre><code>pocketdock logs [--json] [--history] [--follow] [--limit N]\n</code></pre> Option Description <code>--history</code> Show command history <code>--follow</code> Follow log output <code>--limit N</code> Limit number of entries"},{"location":"cli/#container-lifecycle","title":"Container Lifecycle","text":""},{"location":"cli/#create","title":"<code>create</code>","text":"<p>Create a new container.</p> <pre><code>pocketdock create [OPTIONS]\n</code></pre> Option Description <code>--image IMAGE</code> Container image (default: <code>pocketdock/minimal</code>) <code>--name NAME</code> Container name (auto-generated if omitted) <code>--profile PROFILE</code> Image profile (<code>minimal</code>, <code>dev</code>, <code>agent</code>, <code>embedded</code>) <code>--mem-limit LIMIT</code> Memory limit (e.g., <code>256m</code>, <code>1g</code>) <code>--cpu-percent N</code> CPU cap as percentage <code>--persist</code> Make container persistent <code>--device DEVICE</code> Device passthrough (can be repeated) <pre><code>pocketdock create --name my-sandbox --profile dev --mem-limit 512m --persist\n</code></pre>"},{"location":"cli/#run","title":"<code>run</code>","text":"<p>Execute a command inside a container.</p> <pre><code>pocketdock run CONTAINER [OPTIONS] COMMAND...\n</code></pre> Option Description <code>--stream</code> Stream output in real time <code>--detach</code> Run in background <code>--timeout N</code> Command timeout in seconds <code>--lang LANG</code> Language wrapper (e.g., <code>python</code>) <pre><code>pocketdock run my-sandbox echo hello\npocketdock run my-sandbox --stream make all\npocketdock run my-sandbox --detach python server.py\npocketdock run my-sandbox --lang python \"print(2 + 2)\"\n</code></pre>"},{"location":"cli/#shell","title":"<code>shell</code>","text":"<p>Open an interactive shell session.</p> <pre><code>pocketdock shell CONTAINER\n</code></pre> <p>This passes through to the engine's <code>exec -it</code> command (e.g., <code>docker exec -it CONTAINER /bin/sh</code>).</p>"},{"location":"cli/#reboot","title":"<code>reboot</code>","text":"<p>Restart a container.</p> <pre><code>pocketdock reboot CONTAINER [--fresh]\n</code></pre> Option Description <code>--fresh</code> Recreate from scratch (new filesystem)"},{"location":"cli/#stop","title":"<code>stop</code>","text":"<p>Stop a running container without removing it.</p> <pre><code>pocketdock stop CONTAINER\n</code></pre>"},{"location":"cli/#resume","title":"<code>resume</code>","text":"<p>Resume a stopped persistent container.</p> <pre><code>pocketdock resume CONTAINER\n</code></pre>"},{"location":"cli/#shutdown","title":"<code>shutdown</code>","text":"<p>Stop and remove a container.</p> <pre><code>pocketdock shutdown CONTAINER [--yes]\n</code></pre> Option Description <code>--yes / -y</code> Skip confirmation prompt"},{"location":"cli/#snapshot","title":"<code>snapshot</code>","text":"<p>Commit a container's filesystem as a new image.</p> <pre><code>pocketdock snapshot CONTAINER IMAGE_NAME\n</code></pre> <pre><code>pocketdock snapshot my-sandbox my-sandbox:v1\n</code></pre>"},{"location":"cli/#prune","title":"<code>prune</code>","text":"<p>Remove all stopped pocketdock containers.</p> <pre><code>pocketdock prune [--yes] [--project PROJECT]\n</code></pre> Option Description <code>--yes / -y</code> Skip confirmation prompt <code>--project PROJECT</code> Only prune containers for this project"},{"location":"cli/#information-commands","title":"Information Commands","text":""},{"location":"cli/#list","title":"<code>list</code>","text":"<p>List all pocketdock managed containers.</p> <pre><code>pocketdock list [--json] [--project PROJECT]\n</code></pre> <pre><code>pocketdock list\npocketdock list --json\npocketdock list --project my-app\n</code></pre>"},{"location":"cli/#info","title":"<code>info</code>","text":"<p>Show detailed information about a container.</p> <pre><code>pocketdock info CONTAINER [--json]\n</code></pre>"},{"location":"cli/#file-operations","title":"File Operations","text":""},{"location":"cli/#push","title":"<code>push</code>","text":"<p>Copy a file or directory from the host into a container.</p> <pre><code>pocketdock push CONTAINER SRC DEST\n</code></pre> <pre><code>pocketdock push my-sandbox ./src/ /home/sandbox/src/\n</code></pre>"},{"location":"cli/#pull","title":"<code>pull</code>","text":"<p>Copy a file or directory from a container to the host.</p> <pre><code>pocketdock pull CONTAINER SRC DEST\n</code></pre> <pre><code>pocketdock pull my-sandbox /home/sandbox/output.csv ./output.csv\n</code></pre>"},{"location":"cli/#image-profile-commands","title":"Image Profile Commands","text":""},{"location":"cli/#profiles","title":"<code>profiles</code>","text":"<p>List available image profiles.</p> <pre><code>pocketdock profiles [--json]\n</code></pre>"},{"location":"cli/#build","title":"<code>build</code>","text":"<p>Build profile images from Dockerfiles.</p> <pre><code>pocketdock build [PROFILE]\n</code></pre> <pre><code>pocketdock build           # Build all profiles\npocketdock build minimal   # Build a specific profile\n</code></pre>"},{"location":"cli/#export","title":"<code>export</code>","text":"<p>Save images to a tar/tar.gz file for transfer.</p> <pre><code>pocketdock export [OPTIONS] -o OUTPUT\n</code></pre> Option Description <code>--all</code> Export all profile images <code>-o / --output FILE</code> Output file path <pre><code>pocketdock export --all -o images.tar.gz\n</code></pre>"},{"location":"cli/#import","title":"<code>import</code>","text":"<p>Load images from a tar/tar.gz file.</p> <pre><code>pocketdock import FILE\n</code></pre> <pre><code>pocketdock import images.tar.gz\n</code></pre>"},{"location":"cli/#json-output","title":"JSON Output","text":"<p>Read commands support <code>--json</code> for machine-readable output:</p> <pre><code>pocketdock list --json\npocketdock info my-sandbox --json\npocketdock doctor --json\npocketdock status --json\npocketdock logs --json\npocketdock profiles --json\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>See CONTRIBUTING.md for full details.</p>"},{"location":"contributing/#quick-reference","title":"Quick Reference","text":"<pre><code>uv sync --dev                           # Install dependencies\nuv run pytest                           # Run tests\nuv run ruff check .                     # Lint\nuv run ruff format --check .            # Format check\nuv run mypy --strict python/pocketdock/ # Type check\n</code></pre>"},{"location":"contributing/#quality-bar","title":"Quality Bar","text":"<ul> <li>100% line coverage, no exclusions</li> <li>Zero ruff warnings</li> <li>mypy --strict clean</li> <li>bandit clean</li> <li>BSD-2-Clause SPDX header in every source file</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Get a container running in under a minute.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>Container engine: Podman (recommended) or Docker</li> </ul>"},{"location":"quickstart/#install","title":"Install","text":"<pre><code>pip install pocketdock          # SDK only\npip install pocketdock[cli]     # SDK + CLI\n</code></pre>"},{"location":"quickstart/#build-the-minimal-image","title":"Build the Minimal Image","text":"<p>pocketdock ships Dockerfiles for four image profiles. The <code>minimal</code> profile (~25MB, &lt;500ms startup) is the default:</p> <pre><code>pocketdock build minimal\n</code></pre> <p>Or build directly with your container engine:</p> <pre><code># Podman\npodman build -t pocketdock/minimal images/minimal/\n\n# Docker\ndocker build -t pocketdock/minimal images/minimal/\n</code></pre>"},{"location":"quickstart/#run-your-first-container","title":"Run Your First Container","text":"<pre><code>from pocketdock import create_new_container\n\nc = create_new_container()\nresult = c.run(\"echo hello\")\nprint(result.stdout)   # \"hello\\n\"\nprint(result.ok)       # True\nc.shutdown()\n</code></pre>"},{"location":"quickstart/#context-manager","title":"Context Manager","text":"<p>Use a context manager to automatically clean up the container:</p> <pre><code>from pocketdock import create_new_container\n\nwith create_new_container() as c:\n    result = c.run(\"echo hello\")\n    print(result.stdout)\n# Container is stopped and removed automatically\n</code></pre>"},{"location":"quickstart/#run-python-code","title":"Run Python Code","text":"<p>Use the <code>lang</code> parameter to run code in a specific language:</p> <pre><code>with create_new_container() as c:\n    result = c.run(\"print(2 + 2)\", lang=\"python\")\n    print(result.stdout)  # \"4\\n\"\n</code></pre>"},{"location":"quickstart/#file-operations","title":"File Operations","text":"<p>Read and write files inside the container:</p> <pre><code>with create_new_container() as c:\n    c.write_file(\"/home/sandbox/hello.txt\", \"Hello from host!\")\n    data = c.read_file(\"/home/sandbox/hello.txt\")\n    print(data.decode())  # \"Hello from host!\"\n\n    files = c.list_files(\"/home/sandbox/\")\n    print(files)  # [\"hello.txt\"]\n</code></pre>"},{"location":"quickstart/#try-the-cli","title":"Try the CLI","text":"<pre><code># Create a persistent container\npocketdock create --name my-sandbox\n\n# Run a command\npocketdock run my-sandbox echo hello\n\n# Interactive shell\npocketdock shell my-sandbox\n\n# Clean up\npocketdock shutdown my-sandbox --yes\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Creating Containers \u2014 all parameters, resource limits, info, reboot</li> <li>Running Commands \u2014 blocking, streaming, and detached modes</li> <li>Sessions \u2014 persistent shell sessions</li> <li>CLI Reference \u2014 all 21 commands</li> </ul>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>pocketdock talks directly to Podman (or Docker) over its Unix socket using raw HTTP/1.1. The core SDK has zero external dependencies \u2014 it uses only Python stdlib modules.</p>"},{"location":"concepts/architecture/#system-diagram","title":"System Diagram","text":"<pre><code>User Code / LLM Agent / CLI\n        \u2502\n        \u25bc\n  pocketdock SDK\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 Container (sync) \u2500\u2500\u25ba AsyncContainer  \u2502  facade pattern\n  \u2502   \u2514\u2500 _socket_client (raw HTTP/Unix) \u2502\n  \u251c\u2500 ProjectManager (.pocketdock/)      \u2502\n  \u251c\u2500 Persistence (resume, snapshot)      \u2502\n  \u251c\u2500 Sessions (persistent shells)        \u2502\n  \u251c\u2500 Profiles (image registry)           \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502  raw HTTP over Unix socket\n        \u2502  (one connection per operation)\n        \u25bc\n  Podman (rootless) / Docker Engine\n</code></pre>"},{"location":"concepts/architecture/#module-map","title":"Module Map","text":"<pre><code>python/pocketdock/\n\u251c\u2500\u2500 __init__.py              # Sync public exports\n\u251c\u2500\u2500 async_.py                # Async public exports\n\u251c\u2500\u2500 _async_container.py      # AsyncContainer (core implementation)\n\u251c\u2500\u2500 _sync_container.py       # Container (sync facade + _LoopThread)\n\u251c\u2500\u2500 _socket_client.py        # Async HTTP-over-Unix-socket client\n\u251c\u2500\u2500 _helpers.py              # Parsing utilities (bytes, timestamps, CPU)\n\u251c\u2500\u2500 _stream.py               # Stream demux, chunked encoding\n\u251c\u2500\u2500 _process.py              # Detached Process handle\n\u251c\u2500\u2500 _buffer.py               # Ring buffer (1MB default)\n\u251c\u2500\u2500 _session.py              # Persistent shell via long-lived exec\n\u251c\u2500\u2500 _callbacks.py            # Callback registry\n\u251c\u2500\u2500 _logger.py               # Auto stream-to-disk logging\n\u251c\u2500\u2500 _config.py               # Config loading (pocketdock.yaml)\n\u251c\u2500\u2500 pool.py                  # ContainerPool (future)\n\u251c\u2500\u2500 persistence.py           # resume, snapshot, list, destroy, prune\n\u251c\u2500\u2500 projects.py              # .pocketdock/ management\n\u251c\u2500\u2500 profiles.py              # Image profiles registry\n\u251c\u2500\u2500 errors.py                # Exception hierarchy\n\u251c\u2500\u2500 types.py                 # Data classes (ExecResult, ContainerInfo, etc.)\n\u2514\u2500\u2500 cli/                     # Click + Rich CLI\n    \u251c\u2500\u2500 main.py              # Entry point and global options\n    \u2514\u2500\u2500 _commands.py         # All 21 commands\n</code></pre>"},{"location":"concepts/architecture/#key-design-rules","title":"Key Design Rules","text":""},{"location":"concepts/architecture/#connection-per-operation","title":"Connection-per-Operation","text":"<p>Each API call opens its own Unix socket connection, performs the HTTP request, and closes. No connection pooling. Unix sockets are essentially free (no TCP handshake, no TLS). This isolation means streaming, blocking, and detached operations can run simultaneously without interfering.</p> <p>See Connection Model for details.</p>"},{"location":"concepts/architecture/#async-core-sync-facade","title":"Async Core, Sync Facade","text":"<p><code>AsyncContainer</code> contains all real implementation logic. <code>Container</code> is a thin sync wrapper that manages a background event loop thread (<code>_LoopThread</code>). Every sync method call is forwarded to the async version via <code>asyncio.run_coroutine_threadsafe()</code>.</p> <pre><code>Container.run(\"echo hello\")\n    \u2502\n    \u25bc run_coroutine_threadsafe()\nAsyncContainer.run(\"echo hello\")\n    \u2502\n    \u25bc _socket_client.exec_command()\nHTTP POST /exec/{id}/start (Unix socket)\n</code></pre> <p>The <code>_LoopThread</code> is a singleton \u2014 all sync containers share one background event loop.</p>"},{"location":"concepts/architecture/#no-cached-state","title":"No Cached State","text":"<p>pocketdock never caches container state. Every <code>info()</code> call, every <code>is_running()</code> check, every operation hits the engine live. The container might have been killed externally by another process, a resource limit, or an OOM event. Caching would hide these failures.</p>"},{"location":"concepts/architecture/#http-over-unix-socket","title":"HTTP Over Unix Socket","text":"<p>The socket client (<code>_socket_client.py</code>) implements raw HTTP/1.1 over Unix domain sockets using Python's <code>asyncio</code> stream API. It handles:</p> <ul> <li>Request serialization (method, path, headers, body)</li> <li>Response parsing (status, headers, body)</li> <li>Chunked transfer encoding (for streaming)</li> <li>Docker stream demultiplexing (8-byte header frames)</li> <li>Podman raw stream mode (no framing)</li> </ul> <p>No external HTTP library is used. This keeps the dependency count at zero and gives full control over streaming behavior.</p>"},{"location":"concepts/architecture/#three-output-modes","title":"Three Output Modes","text":"<p>The <code>run()</code> method supports three mutually exclusive modes:</p> Mode Parameter Returns Use Case Blocking (default) <code>ExecResult</code> Simple commands Streaming <code>stream=True</code> <code>ExecStream</code> / <code>AsyncExecStream</code> Builds, long scripts Detached <code>detach=True</code> <code>Process</code> / <code>AsyncProcess</code> Background servers <p>All three modes share the same exec creation path (<code>_exec_create</code> + <code>_exec_start</code>) but differ in how they consume the output stream.</p>"},{"location":"concepts/connection-model/","title":"Connection Model","text":""},{"location":"concepts/connection-model/#connection-per-operation","title":"Connection-per-Operation","text":"<p>Every SDK operation opens its own Unix socket connection, performs the HTTP request, and closes the connection. There is no connection pooling, no persistent connections, and no multiplexing.</p> <pre><code>c.run(\"echo hello\")    \u2192 open socket \u2192 HTTP POST /exec \u2192 close socket\nc.info()               \u2192 open socket \u2192 HTTP GET /inspect \u2192 close socket\nc.write_file(...)      \u2192 open socket \u2192 HTTP PUT /archive \u2192 close socket\n</code></pre> <p>Each operation is fully independent.</p>"},{"location":"concepts/connection-model/#why-no-pooling","title":"Why No Pooling?","text":"<p>Unix socket connections are essentially free:</p> <ul> <li>No TCP handshake \u2014 no SYN/SYN-ACK/ACK round trip</li> <li>No TLS negotiation \u2014 communication is local, within the same machine</li> <li>No DNS resolution \u2014 the socket is a filesystem path</li> <li>Kernel-level routing \u2014 data moves through kernel buffers, not the network stack</li> </ul> <p>The cost of opening a Unix socket connection is on the order of microseconds. Connection pooling would add complexity (lifecycle management, health checks, thread safety) without meaningful performance benefit.</p>"},{"location":"concepts/connection-model/#isolation-benefits","title":"Isolation Benefits","text":"<p>Connection-per-operation means:</p> <ul> <li>Streaming doesn't block other operations \u2014 a long-running <code>run(stream=True)</code> holds its own connection while <code>info()</code>, <code>write_file()</code>, or another <code>run()</code> can proceed on separate connections</li> <li>No head-of-line blocking \u2014 each operation's I/O is independent</li> <li>Clean error handling \u2014 if a connection fails, only that operation is affected</li> <li>No stale connections \u2014 no risk of using a connection that the engine has closed</li> </ul>"},{"location":"concepts/connection-model/#socket-auto-detection","title":"Socket Auto-Detection","text":"<p>If no socket path is specified, pocketdock searches in this order:</p> Priority Path Engine 1 <code>$POCKETDOCK_SOCKET</code> env var Any 2 <code>$XDG_RUNTIME_DIR/podman/podman.sock</code> Podman (rootless) 3 <code>/run/podman/podman.sock</code> Podman (system) 4 <code>/var/run/docker.sock</code> Docker <p>Detection checks that the socket file exists and is connectable. The first working socket wins.</p>"},{"location":"concepts/connection-model/#override","title":"Override","text":"<p>Specify a socket explicitly:</p> <pre><code>c = create_new_container(socket_path=\"/path/to/engine.sock\")\n</code></pre> <p>Or via environment variable:</p> <pre><code>export POCKETDOCK_SOCKET=/path/to/engine.sock\n</code></pre> <p>Or via project config (<code>pocketdock.yaml</code>):</p> <pre><code>socket: /path/to/engine.sock\n</code></pre>"},{"location":"concepts/connection-model/#concurrency-model","title":"Concurrency Model","text":""},{"location":"concepts/connection-model/#async-operations","title":"Async Operations","text":"<p>Multiple async operations can run concurrently on the same container:</p> <pre><code>import asyncio\nfrom pocketdock.async_ import create_new_container\n\nasync def main():\n    async with await create_new_container() as c:\n        # These run concurrently, each on its own socket connection\n        r1, r2 = await asyncio.gather(\n            c.run(\"echo one\"),\n            c.run(\"echo two\"),\n        )\n</code></pre>"},{"location":"concepts/connection-model/#sync-operations","title":"Sync Operations","text":"<p>Sync operations are serialized per call (each blocks until complete), but multiple threads can operate on different containers simultaneously. The sync facade uses a shared background event loop thread.</p>"},{"location":"concepts/connection-model/#streaming-and-detached","title":"Streaming and Detached","text":"<p>A streaming or detached process holds its socket connection open for the duration of the stream/process. Other operations on the same container are unaffected because they open their own connections.</p> <pre><code># This works fine \u2014 the stream and run() use separate connections\nstream = c.run(\"make all\", stream=True)\nfor chunk in stream:\n    if \"error\" in chunk.data:\n        # Run a diagnostic command while streaming\n        info = c.info()\n        print(f\"Memory: {info.memory_usage}\")\n</code></pre>"},{"location":"concepts/connection-model/#engine-compatibility","title":"Engine Compatibility","text":"<p>pocketdock supports both Podman and Docker. The socket client handles differences transparently:</p> Feature Docker Podman Stream framing 8-byte demux headers Raw stream (no framing) Chunked encoding Always Sometimes Container name prefix <code>/name</code> <code>name</code> Default socket <code>/var/run/docker.sock</code> <code>$XDG_RUNTIME_DIR/podman/podman.sock</code> Rootless No Yes (default) <p>The API endpoints are compatible \u2014 both engines implement the same REST API for container operations.</p>"},{"location":"guide/async/","title":"Async API","text":"<p>pocketdock is async-first. The sync <code>Container</code> is a thin facade over <code>AsyncContainer</code>, which does all real work. Use the async API directly when you need concurrency or are already in an async context.</p>"},{"location":"guide/async/#import","title":"Import","text":"<pre><code>from pocketdock.async_ import create_new_container\n</code></pre> <p>All async equivalents live in <code>pocketdock.async_</code>:</p> <pre><code>from pocketdock.async_ import (\n    create_new_container,\n    resume_container,\n    list_containers,\n    destroy_container,\n    stop_container,\n    prune,\n    doctor,\n    find_project_root,\n    init_project,\n    resolve_profile,\n    list_profiles,\n)\n</code></pre>"},{"location":"guide/async/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom pocketdock.async_ import create_new_container\n\nasync def main():\n    async with await create_new_container() as c:\n        result = await c.run(\"echo hello\")\n        print(result.stdout)\n\nasyncio.run(main())\n</code></pre> <p>Note</p> <p><code>create_new_container()</code> returns an awaitable. Use <code>await</code> to get the container, then <code>async with</code> for automatic cleanup.</p>"},{"location":"guide/async/#concurrent-containers","title":"Concurrent Containers","text":"<p>Run commands in multiple containers simultaneously:</p> <pre><code>import asyncio\nfrom pocketdock.async_ import create_new_container\n\nasync def main():\n    async with (\n        await create_new_container() as c1,\n        await create_new_container() as c2,\n    ):\n        r1, r2 = await asyncio.gather(\n            c1.run(\"sleep 2 &amp;&amp; echo done-1\"),\n            c2.run(\"sleep 2 &amp;&amp; echo done-2\"),\n        )\n        # Takes ~2 seconds total, not ~4\n        print(r1.stdout)  # \"done-1\\n\"\n        print(r2.stdout)  # \"done-2\\n\"\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/async/#streaming-async","title":"Streaming (Async)","text":"<pre><code>async with await create_new_container() as c:\n    async for chunk in await c.run(\"make all\", stream=True):\n        print(chunk.data, end=\"\")\n</code></pre> <p>The async stream is an <code>AsyncExecStream</code> \u2014 an async iterator of <code>StreamChunk</code> objects.</p>"},{"location":"guide/async/#detached-async","title":"Detached (Async)","text":"<pre><code>async with await create_new_container() as c:\n    proc = await c.run(\"python server.py\", detach=True)\n    await asyncio.sleep(1)\n    print(await proc.is_running())  # True\n    output = proc.peek()\n    print(output.stdout)\n    await proc.kill()\n</code></pre>"},{"location":"guide/async/#sessions-async","title":"Sessions (Async)","text":"<pre><code>async with await create_new_container() as c:\n    sess = await c.session()\n    await sess.send(\"cd /tmp\")\n    result = await sess.send_and_wait(\"pwd\")\n    print(result.stdout)  # \"/tmp\\n\"\n    await sess.close()\n</code></pre>"},{"location":"guide/async/#when-to-use-async-vs-sync","title":"When to Use Async vs Sync","text":"Scenario Recommendation Scripts, CLIs, notebooks Use sync (<code>pocketdock</code>) Already in an async context Use async (<code>pocketdock.async_</code>) Multiple containers concurrently Use async + <code>asyncio.gather()</code> Web frameworks (FastAPI, aiohttp) Use async Simple one-container tasks Use sync"},{"location":"guide/async/#async-types","title":"Async Types","text":"<p>The async API uses different type names for streams and processes:</p> Sync Async <code>ExecStream</code> <code>AsyncExecStream</code> <code>Process</code> <code>AsyncProcess</code> <code>Session</code> <code>AsyncSession</code> <p>These are exported from <code>pocketdock.async_</code>:</p> <pre><code>from pocketdock.async_ import AsyncContainer, AsyncExecStream, AsyncProcess, AsyncSession\n</code></pre>"},{"location":"guide/async/#how-the-sync-facade-works","title":"How the Sync Facade Works","text":"<p>The sync <code>Container</code> class manages a background thread with its own event loop. Every sync method call is forwarded to the async method via <code>asyncio.run_coroutine_threadsafe()</code>. This means:</p> <ul> <li>You can use the sync API from any thread</li> <li>Multiple sync containers share a single background event loop</li> <li>The sync API has minimal overhead beyond the thread hop</li> </ul>"},{"location":"guide/commands/","title":"Running Commands","text":"<p>pocketdock supports three execution modes: blocking, streaming, and detached.</p>"},{"location":"guide/commands/#blocking-mode-default","title":"Blocking Mode (Default)","text":"<p>Run a command, wait for it to finish, get all output at once:</p> <pre><code>result = c.run(\"echo hello\")\nresult.exit_code    # 0\nresult.stdout       # \"hello\\n\"\nresult.stderr       # \"\"\nresult.ok           # True (exit_code == 0 and not timed_out)\nresult.duration_ms  # 47.2\nresult.timed_out    # False\nresult.truncated    # False\n</code></pre>"},{"location":"guide/commands/#run-python-code","title":"Run Python Code","text":"<p>Use <code>lang=\"python\"</code> to wrap the command with <code>python3 -c</code>:</p> <pre><code>result = c.run(\"print(2 + 2)\", lang=\"python\")\nprint(result.stdout)  # \"4\\n\"\n</code></pre>"},{"location":"guide/commands/#timeout","title":"Timeout","text":"<p>Set a per-command timeout (in seconds):</p> <pre><code>result = c.run(\"sleep 60\", timeout=5)\nresult.timed_out  # True\nresult.ok         # False\n</code></pre> <p>The default timeout is set at container creation (30 seconds).</p>"},{"location":"guide/commands/#output-cap","title":"Output Cap","text":"<p>Limit the amount of output collected:</p> <pre><code>result = c.run(\"cat /dev/urandom | head -c 1000000\", max_output=1024)\nresult.truncated  # True\n</code></pre> <p>Default: 10 MB (<code>10_485_760</code> bytes).</p>"},{"location":"guide/commands/#streaming-mode","title":"Streaming Mode","text":"<p>Yield output chunks as they arrive. Useful for builds, long-running scripts, and real-time monitoring:</p> <pre><code>for chunk in c.run(\"make all 2&gt;&amp;1\", stream=True):\n    print(chunk.data, end=\"\")\n    # chunk.stream is \"stdout\" or \"stderr\"\n</code></pre> <p>Each <code>StreamChunk</code> has:</p> <ul> <li><code>stream</code> \u2014 <code>\"stdout\"</code> or <code>\"stderr\"</code></li> <li><code>data</code> \u2014 the text content</li> </ul>"},{"location":"guide/commands/#get-final-result-after-streaming","title":"Get Final Result After Streaming","text":"<p>The stream object exposes a <code>.result</code> property after iteration completes:</p> <pre><code>stream = c.run(\"echo hello &amp;&amp; exit 1\", stream=True)\nfor chunk in stream:\n    print(chunk.data, end=\"\")\nprint(stream.result.exit_code)  # 1\n</code></pre>"},{"location":"guide/commands/#detached-mode","title":"Detached Mode","text":"<p>Start a background process and get a handle to monitor or kill it:</p> <pre><code>proc = c.run(\"python -m http.server 8080\", detach=True)\nproc.is_running()  # True\n</code></pre>"},{"location":"guide/commands/#read-buffered-output","title":"Read Buffered Output","text":"<p>Detached processes write to a ring buffer (1 MB default). Read from it without blocking:</p> <pre><code># Consume and clear the buffer\noutput = proc.read()\nprint(output.stdout)\nprint(output.stderr)\n\n# Peek without consuming\noutput = proc.peek()\n</code></pre> <p>Both return a <code>BufferSnapshot</code> with <code>.stdout</code> and <code>.stderr</code> strings.</p>"},{"location":"guide/commands/#buffer-overflow","title":"Buffer Overflow","text":"<p>Check if the ring buffer has overflowed (older data was evicted):</p> <pre><code>proc.buffer_size      # Current bytes in buffer\nproc.buffer_overflow  # True if data was evicted\n</code></pre>"},{"location":"guide/commands/#wait-for-completion","title":"Wait for Completion","text":"<pre><code>result = proc.wait(timeout=60)  # -&gt; ExecResult\nprint(result.exit_code)\n</code></pre>"},{"location":"guide/commands/#kill","title":"Kill","text":"<pre><code>proc.kill()           # Send SIGTERM (default)\nproc.kill(signal=9)   # Send SIGKILL\n</code></pre>"},{"location":"guide/commands/#callbacks","title":"Callbacks","text":"<p>Register callbacks to be notified of output and exit events on detached processes:</p> <pre><code>c.on_stdout(lambda container, data: print(f\"[out] {data}\", end=\"\"))\nc.on_stderr(lambda container, data: print(f\"[err] {data}\", end=\"\"))\nc.on_exit(lambda container, code: print(f\"Exited with code {code}\"))\n\nproc = c.run(\"python long_task.py\", detach=True)\n</code></pre> <p>Callback signatures:</p> <ul> <li><code>on_stdout(fn)</code> \u2014 <code>fn(container, data: str)</code></li> <li><code>on_stderr(fn)</code> \u2014 <code>fn(container, data: str)</code></li> <li><code>on_exit(fn)</code> \u2014 <code>fn(container, exit_code: int)</code></li> </ul> <p>Callbacks are invoked for all detached processes on the container. They are dispatched synchronously from the read loop.</p>"},{"location":"guide/containers/","title":"Creating Containers","text":""},{"location":"guide/containers/#basic-usage","title":"Basic Usage","text":"<pre><code>from pocketdock import create_new_container\n\nc = create_new_container()\nresult = c.run(\"echo hello\")\nc.shutdown()\n</code></pre> <p>With a context manager:</p> <pre><code>with create_new_container() as c:\n    result = c.run(\"echo hello\")\n# Automatic cleanup\n</code></pre>"},{"location":"guide/containers/#parameters","title":"Parameters","text":"<p><code>create_new_container()</code> accepts the following keyword-only arguments:</p> Parameter Type Default Description <code>image</code> <code>str</code> <code>\"pocketdock/minimal\"</code> Container image tag <code>name</code> <code>str \\| None</code> <code>None</code> Container name (auto-generated as <code>pd-{hex}</code> if <code>None</code>) <code>timeout</code> <code>int</code> <code>30</code> Default exec timeout in seconds <code>mem_limit</code> <code>str \\| None</code> <code>None</code> Memory limit (e.g., <code>\"256m\"</code>, <code>\"1g\"</code>) <code>cpu_percent</code> <code>int \\| None</code> <code>None</code> CPU cap as percentage (e.g., <code>50</code>) <code>persist</code> <code>bool</code> <code>False</code> If <code>True</code>, <code>shutdown()</code> stops but doesn't remove <code>volumes</code> <code>dict[str, str] \\| None</code> <code>None</code> Host-to-container mounts <code>project</code> <code>str \\| None</code> <code>None</code> Project name (auto-detected from <code>.pocketdock/</code>) <code>profile</code> <code>str \\| None</code> <code>None</code> Image profile name (<code>\"minimal\"</code>, <code>\"dev\"</code>, <code>\"agent\"</code>, <code>\"embedded\"</code>) <code>devices</code> <code>list[str] \\| None</code> <code>None</code> Host devices to passthrough (e.g., <code>[\"/dev/ttyUSB0\"]</code>) <pre><code>c = create_new_container(\n    image=\"pocketdock/dev\",\n    name=\"my-sandbox\",\n    timeout=60,\n    mem_limit=\"512m\",\n    cpu_percent=75,\n    persist=True,\n    volumes={\"/host/data\": \"/container/data\"},\n)\n</code></pre>"},{"location":"guide/containers/#container-properties","title":"Container Properties","text":"Property Type Description <code>container_id</code> <code>str</code> Full container ID hex string <code>socket_path</code> <code>str</code> Path to the engine Unix socket <code>name</code> <code>str</code> Human-readable container name <code>persist</code> <code>bool</code> Whether the container survives <code>shutdown()</code> <code>project</code> <code>str</code> Associated project name (empty if none) <code>data_path</code> <code>str</code> Instance data directory path (empty if none)"},{"location":"guide/containers/#container-info","title":"Container Info","text":"<p>Get a live snapshot of the container's state:</p> <pre><code>info = c.info()\n\ninfo.status          # \"running\"\ninfo.image           # \"pocketdock/minimal\"\ninfo.memory_usage    # \"42.1 MB\"\ninfo.memory_limit    # \"256 MB\"\ninfo.memory_percent  # 16.4\ninfo.cpu_percent     # 3.2\ninfo.pids            # 2\ninfo.network         # True\ninfo.ip_address      # \"172.17.0.2\"\ninfo.uptime          # datetime.timedelta(seconds=45)\ninfo.processes       # tuple of process dicts\n</code></pre> <p>See Types &gt; ContainerInfo for all 15 fields.</p>"},{"location":"guide/containers/#resource-limits","title":"Resource Limits","text":"<p>Set memory and CPU limits at creation time:</p> <pre><code># Memory limit: 256MB\nc = create_new_container(mem_limit=\"256m\")\n\n# CPU limit: 50% of one core\nc = create_new_container(cpu_percent=50)\n\n# Both\nc = create_new_container(mem_limit=\"1g\", cpu_percent=75)\n</code></pre> <p>Memory format: <code>\"256m\"</code>, <code>\"512m\"</code>, <code>\"1g\"</code>, <code>\"2g\"</code>, etc.</p>"},{"location":"guide/containers/#reboot","title":"Reboot","text":"<p>Restart the container in place (preserves the filesystem):</p> <pre><code>c.reboot()\n</code></pre> <p>Recreate from scratch with the same configuration (fresh filesystem):</p> <pre><code>c.reboot(fresh=True)\n</code></pre>"},{"location":"guide/containers/#snapshot","title":"Snapshot","text":"<p>Commit the container's current filesystem as a new image:</p> <pre><code>image_id = c.snapshot(\"my-image:v1\")\n</code></pre> <p>The image can be used to create new containers:</p> <pre><code>c2 = create_new_container(image=\"my-image:v1\")\n</code></pre>"},{"location":"guide/containers/#shutdown","title":"Shutdown","text":"<p>Stop and remove the container:</p> <pre><code>c.shutdown()           # Graceful stop (SIGTERM, then SIGKILL after timeout)\nc.shutdown(force=True) # Immediate SIGKILL\n</code></pre> <p>For persistent containers (<code>persist=True</code>), <code>shutdown()</code> only stops \u2014 it doesn't remove:</p> <pre><code>c = create_new_container(persist=True, name=\"my-sandbox\")\nc.shutdown()  # Stops, but container can be resumed later\n</code></pre> <p>See Persistence for resume/destroy operations.</p>"},{"location":"guide/containers/#volumes","title":"Volumes","text":"<p>Mount host directories into the container:</p> <pre><code>c = create_new_container(\n    volumes={\n        \"/host/project/src\": \"/home/sandbox/src\",\n        \"/host/data\": \"/home/sandbox/data\",\n    }\n)\n</code></pre> <p>Volume mounts are read-write. The host path is the dict key, the container path is the value.</p>"},{"location":"guide/files/","title":"File Operations","text":"<p>pocketdock provides five methods for moving data between the host and container.</p>"},{"location":"guide/files/#write-a-file","title":"Write a File","text":"<p>Write text or binary content into the container:</p> <pre><code># Write text\nc.write_file(\"/home/sandbox/config.json\", '{\"debug\": true}')\n\n# Write binary\nc.write_file(\"/home/sandbox/data.bin\", b\"\\x00\\x01\\x02\\x03\")\n</code></pre> <p>The file is created (or overwritten) at the specified path. Parent directories must exist.</p>"},{"location":"guide/files/#read-a-file","title":"Read a File","text":"<p>Read file contents from the container (returns <code>bytes</code>):</p> <pre><code>data = c.read_file(\"/home/sandbox/output.txt\")\nprint(data.decode())  # decode to string if needed\n</code></pre>"},{"location":"guide/files/#list-files","title":"List Files","text":"<p>List a directory inside the container:</p> <pre><code>files = c.list_files(\"/home/sandbox/\")\n# [\"config.json\", \"output.txt\", \"src/\"]\n</code></pre> <p>Default path is <code>/home/sandbox</code>.</p> <pre><code>files = c.list_files()  # Lists /home/sandbox\n</code></pre>"},{"location":"guide/files/#push-host-to-container","title":"Push (Host to Container)","text":"<p>Copy a file or directory from the host into the container:</p> <pre><code># Push a single file\nc.push(\"./local_script.py\", \"/home/sandbox/script.py\")\n\n# Push an entire directory\nc.push(\"./src/\", \"/home/sandbox/src/\")\n</code></pre>"},{"location":"guide/files/#pull-container-to-host","title":"Pull (Container to Host)","text":"<p>Copy a file or directory from the container to the host:</p> <pre><code># Pull a single file\nc.pull(\"/home/sandbox/results.csv\", \"./results.csv\")\n\n# Pull a directory\nc.pull(\"/home/sandbox/output/\", \"./output/\")\n</code></pre>"},{"location":"guide/files/#how-it-works","title":"How It Works","text":"<p>File operations use the container engine's tar archive API under the hood:</p> <ul> <li><code>write_file()</code> creates a single-file tar archive and streams it into the container</li> <li><code>read_file()</code> pulls a tar archive from the container and extracts the file</li> <li><code>push()</code> and <code>pull()</code> use the same tar mechanism for files and directories</li> <li><code>list_files()</code> executes <code>ls</code> inside the container</li> </ul> <p>All operations open a fresh Unix socket connection (connection-per-operation), so file transfers don't block other operations.</p>"},{"location":"guide/persistence/","title":"Persistence","text":"<p>By default, containers are ephemeral \u2014 they are removed when <code>shutdown()</code> is called or the context manager exits. Persistence features let you stop, resume, snapshot, and manage containers across sessions.</p>"},{"location":"guide/persistence/#persistent-containers","title":"Persistent Containers","text":"<p>Create a container that survives <code>shutdown()</code>:</p> <pre><code>from pocketdock import create_new_container\n\nc = create_new_container(persist=True, name=\"my-sandbox\")\nc.run(\"echo setup done\")\nc.shutdown()  # Stops the container, but does NOT remove it\n</code></pre>"},{"location":"guide/persistence/#resume","title":"Resume","text":"<p>Resume a stopped persistent container by name:</p> <pre><code>from pocketdock import resume_container\n\nc = resume_container(\"my-sandbox\")\nresult = c.run(\"echo I'm back\")\nprint(result.stdout)  # \"I'm back\\n\"\n</code></pre> <p>The container's filesystem state is preserved from the previous session.</p>"},{"location":"guide/persistence/#list-containers","title":"List Containers","text":"<p>List all pocketdock managed containers (running and stopped):</p> <pre><code>from pocketdock import list_containers\n\ncontainers = list_containers()\nfor item in containers:\n    print(f\"{item.name}: {item.status} (persist={item.persist})\")\n</code></pre> <p>Each item is a <code>ContainerListItem</code> with:</p> Field Type Description <code>id</code> <code>str</code> Container ID <code>name</code> <code>str</code> Container name <code>status</code> <code>str</code> <code>\"running\"</code> or <code>\"exited\"</code> <code>image</code> <code>str</code> Image tag <code>created_at</code> <code>str</code> ISO creation timestamp <code>persist</code> <code>bool</code> Whether the container is persistent <code>project</code> <code>str</code> Associated project name <p>Filter by project:</p> <pre><code>containers = list_containers(project=\"my-project\")\n</code></pre>"},{"location":"guide/persistence/#stop","title":"Stop","text":"<p>Stop a running container without removing it:</p> <pre><code>from pocketdock import stop_container\n\nstop_container(\"my-sandbox\")\n</code></pre>"},{"location":"guide/persistence/#destroy","title":"Destroy","text":"<p>Permanently remove a container regardless of its persist setting:</p> <pre><code>from pocketdock import destroy_container\n\ndestroy_container(\"my-sandbox\")\n</code></pre> <p>If the container has an associated instance directory (from project management), it is also cleaned up.</p>"},{"location":"guide/persistence/#prune","title":"Prune","text":"<p>Remove all stopped pocketdock managed containers:</p> <pre><code>from pocketdock import prune\n\ncount = prune()\nprint(f\"Removed {count} containers\")\n</code></pre> <p>Filter by project:</p> <pre><code>count = prune(project=\"my-project\")\n</code></pre>"},{"location":"guide/persistence/#snapshot","title":"Snapshot","text":"<p>Commit the container's current filesystem as a reusable image:</p> <pre><code>c = create_new_container(persist=True, name=\"my-sandbox\")\nc.run(\"pip install requests\")\nimage_id = c.snapshot(\"my-sandbox:with-requests\")\n</code></pre> <p>Create new containers from the snapshot:</p> <pre><code>c2 = create_new_container(image=\"my-sandbox:with-requests\")\n</code></pre>"},{"location":"guide/persistence/#volumes","title":"Volumes","text":"<p>Mount host directories for data that should persist independently of the container:</p> <pre><code>c = create_new_container(\n    volumes={\"/host/data\": \"/container/data\"}\n)\n</code></pre> <p>Volume changes are written directly to the host filesystem and survive container removal.</p>"},{"location":"guide/persistence/#socket-path","title":"Socket Path","text":"<p>All persistence functions accept an optional <code>socket_path</code> parameter to target a specific engine:</p> <pre><code>containers = list_containers(socket_path=\"/path/to/docker.sock\")\n</code></pre>"},{"location":"guide/profiles/","title":"Image Profiles","text":"<p>pocketdock ships four pre-baked Dockerfiles for common use cases.</p>"},{"location":"guide/profiles/#available-profiles","title":"Available Profiles","text":"Profile Size Base Contents Default Network minimal ~25 MB Alpine 3.21 Python 3, pip, bash Disabled dev ~250 MB python:3.12-slim Git, curl, jq, vim, build tools, ipython Enabled agent ~350 MB python:3.12-slim requests, pandas, numpy, beautifulsoup4, pillow Disabled embedded ~450 MB Alpine 3.21 GCC, CMake, ARM cross-compiler, Arduino CLI, PlatformIO Enabled"},{"location":"guide/profiles/#using-profiles","title":"Using Profiles","text":""},{"location":"guide/profiles/#with-the-profile-parameter","title":"With the <code>profile</code> Parameter","text":"<pre><code>from pocketdock import create_new_container\n\nwith create_new_container(profile=\"dev\") as c:\n    result = c.run(\"python --version\")\n    print(result.stdout)\n</code></pre> <p>The <code>profile</code> parameter resolves to the profile's image tag (e.g., <code>pocketdock/dev</code>) and applies the profile's default network setting.</p>"},{"location":"guide/profiles/#with-the-image-parameter","title":"With the <code>image</code> Parameter","text":"<p>You can also specify the image tag directly:</p> <pre><code>with create_new_container(image=\"pocketdock/agent\") as c:\n    result = c.run(\"python -c 'import pandas; print(pandas.__version__)'\", lang=None)\n</code></pre>"},{"location":"guide/profiles/#building-profiles","title":"Building Profiles","text":""},{"location":"guide/profiles/#via-cli","title":"Via CLI","text":"<pre><code># Build all profiles\npocketdock build\n\n# Build a specific profile\npocketdock build minimal\npocketdock build dev\n</code></pre>"},{"location":"guide/profiles/#via-container-engine","title":"Via Container Engine","text":"<pre><code>docker build -t pocketdock/minimal images/minimal/\ndocker build -t pocketdock/dev images/dev/\ndocker build -t pocketdock/agent images/agent/\ndocker build -t pocketdock/embedded images/embedded/\n</code></pre>"},{"location":"guide/profiles/#listing-profiles","title":"Listing Profiles","text":""},{"location":"guide/profiles/#sdk","title":"SDK","text":"<pre><code>from pocketdock import list_profiles, resolve_profile\n\n# List all profiles\nprofiles = list_profiles()\nfor p in profiles:\n    print(f\"{p.name}: {p.description} ({p.size_estimate})\")\n\n# Resolve a single profile\ninfo = resolve_profile(\"dev\")\ninfo.name            # \"dev\"\ninfo.image_tag       # \"pocketdock/dev\"\ninfo.network_default # True\ninfo.description     # \"Development tools, git, curl, ...\"\ninfo.size_estimate   # \"~250 MB\"\ninfo.dockerfile_dir  # path to Dockerfile directory\n</code></pre>"},{"location":"guide/profiles/#cli","title":"CLI","text":"<pre><code>pocketdock profiles\npocketdock profiles --json\n</code></pre>"},{"location":"guide/profiles/#export-and-import","title":"Export and Import","text":"<p>Transfer images between machines for air-gapped environments:</p> <pre><code># Export all profile images to a tar.gz file\npocketdock export --all -o images.tar.gz\n\n# Import on another machine\npocketdock import images.tar.gz\n</code></pre>"},{"location":"guide/profiles/#device-passthrough","title":"Device Passthrough","text":"<p>For the <code>embedded</code> profile (or any container), pass host devices into the container:</p> <pre><code>with create_new_container(profile=\"embedded\", devices=[\"/dev/ttyUSB0\"]) as c:\n    result = c.run(\"ls /dev/ttyUSB0\")\n</code></pre> <p>The <code>devices</code> parameter accepts a list of host device paths.</p>"},{"location":"guide/profiles/#profileinfo","title":"ProfileInfo","text":"<p>Each profile is represented as a <code>ProfileInfo</code> dataclass:</p> Field Type Description <code>name</code> <code>str</code> Profile name (e.g., <code>\"minimal\"</code>) <code>image_tag</code> <code>str</code> Docker/Podman image tag <code>dockerfile_dir</code> <code>str</code> Path to the Dockerfile directory <code>network_default</code> <code>bool</code> Whether networking is enabled by default <code>description</code> <code>str</code> Human-readable description <code>size_estimate</code> <code>str</code> Approximate image size"},{"location":"guide/projects/","title":"Projects","text":"<p>pocketdock projects group containers with a shared configuration directory (<code>.pocketdock/</code>) that lives next to your code.</p>"},{"location":"guide/projects/#initialize-a-project","title":"Initialize a Project","text":"<pre><code>from pocketdock import init_project\n\nproject_root = init_project()  # Creates .pocketdock/ in the current directory\n</code></pre> <p>Or specify a path:</p> <pre><code>project_root = init_project(\"/path/to/my-project\")\n</code></pre> <p>With a custom project name:</p> <pre><code>project_root = init_project(project_name=\"my-app\")\n</code></pre> <p>This creates:</p> <pre><code>my-project/\n\u251c\u2500\u2500 .pocketdock/\n\u2502   \u2514\u2500\u2500 pocketdock.yaml\n\u2514\u2500\u2500 ... (your code)\n</code></pre>"},{"location":"guide/projects/#find-project-root","title":"Find Project Root","text":"<p>Walk up from a directory to find the nearest <code>.pocketdock/pocketdock.yaml</code>:</p> <pre><code>from pocketdock import find_project_root\n\nroot = find_project_root()  # Starts from cwd\nroot = find_project_root(\"/some/nested/dir\")\n</code></pre> <p>Returns <code>None</code> if no project is found.</p>"},{"location":"guide/projects/#project-configuration","title":"Project Configuration","text":"<p>The <code>pocketdock.yaml</code> file configures project defaults:</p> <pre><code>project_name: my-app\ndefault_profile: minimal\ndefault_persist: false\nauto_log: true\nmax_log_size: 10MB\nmax_logs_per_instance: 100\nretention_days: 30\nsocket: null\nlog_level: info\n</code></pre> <p>See Configuration for full details.</p>"},{"location":"guide/projects/#associate-containers-with-a-project","title":"Associate Containers with a Project","text":"<p>Pass the <code>project</code> parameter when creating containers:</p> <pre><code>c = create_new_container(project=\"my-app\", persist=True)\n</code></pre> <p>If you're inside a project directory, the project is auto-detected:</p> <pre><code># Inside a directory with .pocketdock/pocketdock.yaml\nc = create_new_container(persist=True)\n# project is auto-detected from the nearest .pocketdock/\n</code></pre>"},{"location":"guide/projects/#instance-directories","title":"Instance Directories","text":"<p>Each persistent container in a project gets its own instance directory:</p> <pre><code>.pocketdock/\n\u251c\u2500\u2500 pocketdock.yaml\n\u2514\u2500\u2500 instances/\n    \u2514\u2500\u2500 my-sandbox/\n        \u251c\u2500\u2500 instance.toml    # Container metadata\n        \u251c\u2500\u2500 history.jsonl    # Command history\n        \u2514\u2500\u2500 logs/            # Session and detach logs\n</code></pre>"},{"location":"guide/projects/#instance-metadata","title":"Instance Metadata","text":"<p><code>instance.toml</code> contains container metadata:</p> <pre><code>container_id = \"abc123...\"\nname = \"my-sandbox\"\nimage = \"pocketdock/minimal\"\nproject = \"my-app\"\ncreated_at = \"2026-01-15T10:30:00\"\npersist = true\nmem_limit = \"256m\"\ncpu_percent = 50\n</code></pre>"},{"location":"guide/projects/#command-history","title":"Command History","text":"<p><code>history.jsonl</code> logs every <code>run()</code> call with timestamps, commands, exit codes, and durations.</p>"},{"location":"guide/projects/#doctor","title":"Doctor","text":"<p>Diagnose project health by cross-referencing local instance directories with the container engine:</p> <pre><code>from pocketdock import doctor\n\nreport = doctor()\nreport.orphaned_containers    # Containers with no instance dir\nreport.stale_instance_dirs    # Instance dirs with no container\nreport.healthy                # Count of healthy container-dir pairs\n</code></pre> <p>The <code>DoctorReport</code> fields:</p> Field Type Description <code>orphaned_containers</code> <code>tuple[str, ...]</code> Container names without matching instance dirs <code>stale_instance_dirs</code> <code>tuple[str, ...]</code> Instance dir names without matching containers <code>healthy</code> <code>int</code> Count of healthy pairs"},{"location":"guide/projects/#projectnotinitialized","title":"ProjectNotInitialized","text":"<p>If <code>doctor()</code> is called outside a project directory, it raises <code>ProjectNotInitialized</code>:</p> <pre><code>from pocketdock import ProjectNotInitialized\n\ntry:\n    report = doctor()\nexcept ProjectNotInitialized:\n    print(\"Run init_project() first\")\n</code></pre>"},{"location":"guide/sessions/","title":"Sessions","text":"<p>Sessions provide persistent shell connections to a container. Unlike <code>run()</code>, which creates a new exec instance for each command, a session maintains a single long-lived shell process with preserved state (working directory, environment variables, shell history).</p>"},{"location":"guide/sessions/#create-a-session","title":"Create a Session","text":"<pre><code>sess = c.session()\n</code></pre> <p>The session opens a <code>/bin/sh</code> shell inside the container and keeps it alive until explicitly closed or the container shuts down.</p>"},{"location":"guide/sessions/#send-and-wait","title":"Send and Wait","text":"<p>Send a command and wait for it to complete:</p> <pre><code>result = sess.send_and_wait(\"echo hello\")\nresult.stdout      # \"hello\\n\"\nresult.exit_code   # 0\nresult.ok          # True\nresult.duration_ms # 12.3\n</code></pre> <p>With a timeout:</p> <pre><code>result = sess.send_and_wait(\"sleep 60\", timeout=5)\nresult.timed_out  # True\n</code></pre>"},{"location":"guide/sessions/#fire-and-forget","title":"Fire-and-Forget","text":"<p>Send a command without waiting for output:</p> <pre><code>sess.send(\"cd /tmp\")\nsess.send(\"export MY_VAR=hello\")\n</code></pre> <p>State persists across commands:</p> <pre><code>sess.send(\"cd /tmp\")\nresult = sess.send_and_wait(\"pwd\")\nprint(result.stdout)  # \"/tmp\\n\"\n</code></pre>"},{"location":"guide/sessions/#read-accumulated-output","title":"Read Accumulated Output","text":"<p>Drain any output that has accumulated since the last read:</p> <pre><code>sess.send(\"echo line1\")\nsess.send(\"echo line2\")\nimport time; time.sleep(0.1)\n\noutput = sess.read()\nprint(output)  # \"line1\\nline2\\n\"\n</code></pre> <p><code>read()</code> is thread-safe and clears the buffer.</p>"},{"location":"guide/sessions/#output-callback","title":"Output Callback","text":"<p>Register a callback for session output:</p> <pre><code>sess.on_output(lambda data: print(f\"[session] {data}\", end=\"\"))\n</code></pre> <p>The callback receives all output from the shell, including command echoes.</p>"},{"location":"guide/sessions/#close","title":"Close","text":"<p>Close the session without stopping the container:</p> <pre><code>sess.close()\n</code></pre> <p>After closing, any further operations raise <code>SessionClosed</code>:</p> <pre><code>from pocketdock import SessionClosed\n\nsess.close()\ntry:\n    sess.send(\"echo hello\")\nexcept SessionClosed:\n    print(\"Session is closed\")\n</code></pre>"},{"location":"guide/sessions/#session-properties","title":"Session Properties","text":"Property Type Description <code>id</code> <code>str</code> Exec instance ID backing the session"},{"location":"guide/sessions/#sentinel-protocol","title":"Sentinel Protocol","text":"<p>pocketdock uses a sentinel protocol to reliably detect command boundaries and exit codes. After each <code>send_and_wait()</code> command, the session injects a sentinel marker (<code>__PD_{uuid}_${exit_code}__</code>) to determine where one command's output ends and the next begins. This is transparent to the user.</p>"},{"location":"guide/sessions/#automatic-cleanup","title":"Automatic Cleanup","text":"<p>Sessions are automatically closed when the container shuts down:</p> <pre><code>with create_new_container() as c:\n    sess = c.session()\n    result = sess.send_and_wait(\"echo hello\")\n# Session and container are both cleaned up\n</code></pre>"},{"location":"reference/api/","title":"API Reference","text":""},{"location":"reference/api/#module-pocketdock","title":"Module: <code>pocketdock</code>","text":"<p>Sync API. All container operations are blocking.</p>"},{"location":"reference/api/#container-creation","title":"Container Creation","text":""},{"location":"reference/api/#create_new_containerkwargs-container","title":"<code>create_new_container(**kwargs) -&gt; Container</code>","text":"<p>Create and start a new container.</p> <pre><code>from pocketdock import create_new_container\n\nc = create_new_container(\n    image=\"pocketdock/minimal\",  # Container image tag\n    name=None,                     # Auto-generated if None\n    timeout=30,                    # Default exec timeout (seconds)\n    mem_limit=None,                # Memory limit (\"256m\", \"1g\")\n    cpu_percent=None,              # CPU cap (0-100)\n    persist=False,                 # Survive shutdown()\n    volumes=None,                  # {\"/host\": \"/container\"}\n    project=None,                  # Project name\n    profile=None,                  # Image profile name\n    devices=None,                  # [\"/dev/ttyUSB0\"]\n)\n</code></pre> <p>All parameters are keyword-only.</p>"},{"location":"reference/api/#container-management","title":"Container Management","text":""},{"location":"reference/api/#resume_containername-socket_pathnone-timeout30-container","title":"<code>resume_container(name, *, socket_path=None, timeout=30) -&gt; Container</code>","text":"<p>Resume a stopped persistent container by name.</p>"},{"location":"reference/api/#list_containers-socket_pathnone-projectnone-listcontainerlistitem","title":"<code>list_containers(*, socket_path=None, project=None) -&gt; list[ContainerListItem]</code>","text":"<p>List all pocketdock managed containers (running and stopped).</p>"},{"location":"reference/api/#stop_containername-socket_pathnone-none","title":"<code>stop_container(name, *, socket_path=None) -&gt; None</code>","text":"<p>Stop a running container without removing it.</p>"},{"location":"reference/api/#destroy_containername-socket_pathnone-none","title":"<code>destroy_container(name, *, socket_path=None) -&gt; None</code>","text":"<p>Permanently remove a container.</p>"},{"location":"reference/api/#prune-socket_pathnone-projectnone-int","title":"<code>prune(*, socket_path=None, project=None) -&gt; int</code>","text":"<p>Remove all stopped pocketdock containers. Returns the count of removed containers.</p>"},{"location":"reference/api/#doctor-project_rootnone-socket_pathnone-doctorreport","title":"<code>doctor(*, project_root=None, socket_path=None) -&gt; DoctorReport</code>","text":"<p>Cross-reference local instance directories with the container engine.</p>"},{"location":"reference/api/#project-management","title":"Project Management","text":""},{"location":"reference/api/#find_project_rootstartnone-path-none","title":"<code>find_project_root(start=None) -&gt; Path | None</code>","text":"<p>Walk up from <code>start</code> (default: cwd) looking for <code>.pocketdock/pocketdock.yaml</code>. Returns the project root directory, or <code>None</code>.</p>"},{"location":"reference/api/#init_projectpathnone-project_namenone-path","title":"<code>init_project(path=None, *, project_name=None) -&gt; Path</code>","text":"<p>Create a <code>.pocketdock/pocketdock.yaml</code> file. Returns the project root path.</p>"},{"location":"reference/api/#profile-management","title":"Profile Management","text":""},{"location":"reference/api/#resolve_profilename-profileinfo","title":"<code>resolve_profile(name) -&gt; ProfileInfo</code>","text":"<p>Look up a profile by name. Returns a <code>ProfileInfo</code> dataclass.</p>"},{"location":"reference/api/#list_profiles-listprofileinfo","title":"<code>list_profiles() -&gt; list[ProfileInfo]</code>","text":"<p>Return all available profiles.</p>"},{"location":"reference/api/#version","title":"Version","text":""},{"location":"reference/api/#get_version-str","title":"<code>get_version() -&gt; str</code>","text":"<p>Return the package version string.</p>"},{"location":"reference/api/#__version__-str","title":"<code>__version__: str</code>","text":"<p>Package version (e.g., <code>\"1.0.1\"</code>).</p>"},{"location":"reference/api/#class-container","title":"Class: <code>Container</code>","text":"<p>Sync container handle. Wraps <code>AsyncContainer</code> with a background event loop.</p>"},{"location":"reference/api/#properties","title":"Properties","text":"Property Type Description <code>container_id</code> <code>str</code> Full container ID <code>socket_path</code> <code>str</code> Engine socket path <code>name</code> <code>str</code> Container name <code>persist</code> <code>bool</code> Persistent container <code>project</code> <code>str</code> Project name <code>data_path</code> <code>str</code> Instance data directory"},{"location":"reference/api/#methods","title":"Methods","text":""},{"location":"reference/api/#runcommand-streamfalse-detachfalse-timeoutnone-max_output10_485_760-langnone","title":"<code>run(command, *, stream=False, detach=False, timeout=None, max_output=10_485_760, lang=None)</code>","text":"<p>Execute a command inside the container.</p> <p>Returns:</p> <ul> <li>Default: <code>ExecResult</code> \u2014 blocking execution</li> <li><code>stream=True</code>: <code>ExecStream</code> \u2014 sync iterator of <code>StreamChunk</code></li> <li><code>detach=True</code>: <code>Process</code> \u2014 background process handle</li> </ul>"},{"location":"reference/api/#info-containerinfo","title":"<code>info() -&gt; ContainerInfo</code>","text":"<p>Live container snapshot with status, resources, and processes.</p>"},{"location":"reference/api/#reboot-freshfalse-none","title":"<code>reboot(*, fresh=False) -&gt; None</code>","text":"<p>Restart the container. <code>fresh=True</code> recreates from scratch.</p>"},{"location":"reference/api/#write_filepath-content-none","title":"<code>write_file(path, content) -&gt; None</code>","text":"<p>Write text (<code>str</code>) or binary (<code>bytes</code>) content to a file in the container.</p>"},{"location":"reference/api/#read_filepath-bytes","title":"<code>read_file(path) -&gt; bytes</code>","text":"<p>Read file contents from the container.</p>"},{"location":"reference/api/#list_filespathhomesandbox-liststr","title":"<code>list_files(path=\"/home/sandbox\") -&gt; list[str]</code>","text":"<p>List a directory inside the container.</p>"},{"location":"reference/api/#pushsrc-dest-none","title":"<code>push(src, dest) -&gt; None</code>","text":"<p>Copy a file or directory from the host into the container.</p>"},{"location":"reference/api/#pullsrc-dest-none","title":"<code>pull(src, dest) -&gt; None</code>","text":"<p>Copy a file or directory from the container to the host.</p>"},{"location":"reference/api/#session-session","title":"<code>session() -&gt; Session</code>","text":"<p>Open a persistent shell session.</p>"},{"location":"reference/api/#snapshotimage_name-str","title":"<code>snapshot(image_name) -&gt; str</code>","text":"<p>Commit the container's filesystem as a new image. Returns the image ID.</p>"},{"location":"reference/api/#shutdown-forcefalse-none","title":"<code>shutdown(*, force=False) -&gt; None</code>","text":"<p>Stop and remove the container. For persistent containers, stop only.</p>"},{"location":"reference/api/#on_stdoutfn-none","title":"<code>on_stdout(fn) -&gt; None</code>","text":"<p>Register a stdout callback: <code>fn(container, data: str)</code>.</p>"},{"location":"reference/api/#on_stderrfn-none","title":"<code>on_stderr(fn) -&gt; None</code>","text":"<p>Register a stderr callback: <code>fn(container, data: str)</code>.</p>"},{"location":"reference/api/#on_exitfn-none","title":"<code>on_exit(fn) -&gt; None</code>","text":"<p>Register an exit callback: <code>fn(container, exit_code: int)</code>.</p>"},{"location":"reference/api/#class-session","title":"Class: <code>Session</code>","text":"<p>Persistent shell session (sync). Alias for <code>SyncSession</code>.</p>"},{"location":"reference/api/#properties_1","title":"Properties","text":"Property Type Description <code>id</code> <code>str</code> Exec instance ID"},{"location":"reference/api/#methods_1","title":"Methods","text":""},{"location":"reference/api/#sendcommand-none","title":"<code>send(command) -&gt; None</code>","text":"<p>Fire-and-forget command.</p>"},{"location":"reference/api/#send_and_waitcommand-timeoutnone-execresult","title":"<code>send_and_wait(command, *, timeout=None) -&gt; ExecResult</code>","text":"<p>Send command and wait for result.</p>"},{"location":"reference/api/#read-str","title":"<code>read() -&gt; str</code>","text":"<p>Drain accumulated output.</p>"},{"location":"reference/api/#on_outputfn-none","title":"<code>on_output(fn) -&gt; None</code>","text":"<p>Register output callback: <code>fn(data: str)</code>.</p>"},{"location":"reference/api/#close-none","title":"<code>close() -&gt; None</code>","text":"<p>Close the session.</p>"},{"location":"reference/api/#class-execstream","title":"Class: <code>ExecStream</code>","text":"<p>Sync iterator of <code>StreamChunk</code> objects. Alias for <code>SyncExecStream</code>.</p>"},{"location":"reference/api/#properties_2","title":"Properties","text":"Property Type Description <code>result</code> <code>ExecResult</code> Available after iteration completes"},{"location":"reference/api/#usage","title":"Usage","text":"<pre><code>for chunk in c.run(\"make all\", stream=True):\n    print(chunk.data, end=\"\")\n</code></pre>"},{"location":"reference/api/#class-process","title":"Class: <code>Process</code>","text":"<p>Detached process handle (sync). Alias for <code>SyncProcess</code>.</p>"},{"location":"reference/api/#properties_3","title":"Properties","text":"Property Type Description <code>id</code> <code>str</code> Exec instance ID <code>buffer_size</code> <code>int</code> Current bytes in buffer <code>buffer_overflow</code> <code>bool</code> True if data evicted"},{"location":"reference/api/#methods_2","title":"Methods","text":""},{"location":"reference/api/#is_running-bool","title":"<code>is_running() -&gt; bool</code>","text":"<p>Check if the process is still running.</p>"},{"location":"reference/api/#killsignal15-none","title":"<code>kill(signal=15) -&gt; None</code>","text":"<p>Send a signal to the process.</p>"},{"location":"reference/api/#waittimeoutnone-execresult","title":"<code>wait(timeout=None) -&gt; ExecResult</code>","text":"<p>Wait for process completion.</p>"},{"location":"reference/api/#read-buffersnapshot","title":"<code>read() -&gt; BufferSnapshot</code>","text":"<p>Consume and clear the buffer.</p>"},{"location":"reference/api/#peek-buffersnapshot","title":"<code>peek() -&gt; BufferSnapshot</code>","text":"<p>Read without consuming.</p>"},{"location":"reference/api/#module-pocketdockasync_","title":"Module: <code>pocketdock.async_</code>","text":"<p>Async API. All methods are coroutines (use <code>await</code>).</p>"},{"location":"reference/api/#create_new_containerkwargs-asynccontainer","title":"<code>create_new_container(**kwargs) -&gt; AsyncContainer</code>","text":"<p>Same parameters as the sync version. Returns an <code>AsyncContainer</code>.</p> <pre><code>async with await create_new_container() as c:\n    result = await c.run(\"echo hello\")\n</code></pre>"},{"location":"reference/api/#async-functions","title":"Async Functions","text":"<p>All management functions mirror the sync API:</p> <ul> <li><code>resume_container(name, ...) -&gt; AsyncContainer</code></li> <li><code>list_containers(...) -&gt; list[ContainerListItem]</code></li> <li><code>stop_container(name, ...) -&gt; None</code></li> <li><code>destroy_container(name, ...) -&gt; None</code></li> <li><code>prune(...) -&gt; int</code></li> <li><code>doctor(...) -&gt; DoctorReport</code></li> </ul>"},{"location":"reference/api/#class-asynccontainer","title":"Class: <code>AsyncContainer</code>","text":"<p>Same interface as <code>Container</code> but all methods are coroutines.</p>"},{"location":"reference/api/#class-asyncsession","title":"Class: <code>AsyncSession</code>","text":"<p>Same interface as <code>Session</code> but <code>send()</code>, <code>send_and_wait()</code>, and <code>close()</code> are coroutines.</p>"},{"location":"reference/api/#class-asyncexecstream","title":"Class: <code>AsyncExecStream</code>","text":"<p>Async iterator of <code>StreamChunk</code>:</p> <pre><code>async for chunk in await c.run(\"make all\", stream=True):\n    print(chunk.data, end=\"\")\n</code></pre>"},{"location":"reference/api/#class-asyncprocess","title":"Class: <code>AsyncProcess</code>","text":"<p>Same as <code>Process</code> but <code>is_running()</code>, <code>kill()</code>, and <code>wait()</code> are coroutines.</p>"},{"location":"reference/configuration/","title":"Configuration","text":"<p>pocketdock uses a layered configuration system with project-level and environment-level settings.</p>"},{"location":"reference/configuration/#pocketdockyaml","title":"pocketdock.yaml","text":"<p>The primary configuration file, located at <code>.pocketdock/pocketdock.yaml</code> in your project root:</p> <pre><code>project_name: my-app\ndefault_profile: minimal\ndefault_persist: false\nauto_log: true\nmax_log_size: 10MB\nmax_logs_per_instance: 100\nretention_days: 30\nsocket: null\nlog_level: info\n</code></pre>"},{"location":"reference/configuration/#fields","title":"Fields","text":"Field Type Default Description <code>project_name</code> <code>str</code> <code>\"\"</code> Human-readable project name <code>default_profile</code> <code>str</code> <code>\"minimal\"</code> Default image profile for <code>create_new_container()</code> <code>default_persist</code> <code>bool</code> <code>false</code> Default persist setting for new containers <code>auto_log</code> <code>bool</code> <code>true</code> Automatically log <code>run()</code> results and session I/O <code>max_log_size</code> <code>str</code> <code>\"10MB\"</code> Maximum size per log file <code>max_logs_per_instance</code> <code>int</code> <code>100</code> Maximum log files per instance <code>retention_days</code> <code>int</code> <code>30</code> Days to retain log files <code>socket</code> <code>str \\| null</code> <code>null</code> Container engine socket path (overrides auto-detection) <code>log_level</code> <code>str</code> <code>\"info\"</code> Log level (<code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>)"},{"location":"reference/configuration/#environment-variables","title":"Environment Variables","text":"Variable Description <code>POCKETDOCK_SOCKET</code> Container engine socket path (overrides config and auto-detection)"},{"location":"reference/configuration/#config-precedence","title":"Config Precedence","text":"<p>Configuration is resolved in this order (highest priority first):</p> <ol> <li>Explicit parameters \u2014 <code>socket_path</code> passed to functions</li> <li>Environment variables \u2014 <code>POCKETDOCK_SOCKET</code></li> <li>Project config \u2014 <code>.pocketdock/pocketdock.yaml</code></li> <li>Auto-detection \u2014 built-in socket discovery</li> </ol>"},{"location":"reference/configuration/#socket-auto-detection","title":"Socket Auto-Detection","text":"<p>If no socket is specified, pocketdock searches in this order:</p> <ol> <li><code>POCKETDOCK_SOCKET</code> environment variable</li> <li>Podman rootless: <code>$XDG_RUNTIME_DIR/podman/podman.sock</code></li> <li>Podman system: <code>/run/podman/podman.sock</code></li> <li>Docker: <code>/var/run/docker.sock</code></li> </ol>"},{"location":"reference/configuration/#loading-config-programmatically","title":"Loading Config Programmatically","text":"<pre><code>from pocketdock._config import load_config, PocketDockConfig\n\nconfig = load_config()  # Auto-discovers project root\nconfig = load_config(project_root=Path(\"/path/to/project\"))\n\nconfig.project_name      # \"my-app\"\nconfig.default_profile   # \"minimal\"\nconfig.auto_log          # True\n</code></pre>"},{"location":"reference/configuration/#pocketdockconfig-fields","title":"PocketDockConfig Fields","text":"Field Type Default <code>project_name</code> <code>str</code> <code>\"\"</code> <code>default_profile</code> <code>str</code> <code>\"minimal\"</code> <code>default_persist</code> <code>bool</code> <code>False</code> <code>auto_log</code> <code>bool</code> <code>True</code> <code>max_log_size</code> <code>str</code> <code>\"10MB\"</code> <code>max_logs_per_instance</code> <code>int</code> <code>100</code> <code>retention_days</code> <code>int</code> <code>30</code> <code>socket</code> <code>str \\| None</code> <code>None</code> <code>log_level</code> <code>str</code> <code>\"info\"</code>"},{"location":"reference/configuration/#instancetoml","title":"instance.toml","text":"<p>Each persistent container in a project gets an <code>instance.toml</code> metadata file:</p> <pre><code>.pocketdock/instances/my-sandbox/instance.toml\n</code></pre> <pre><code>container_id = \"abc123def456...\"\nname = \"my-sandbox\"\nimage = \"pocketdock/minimal\"\nproject = \"my-app\"\ncreated_at = \"2026-01-15T10:30:00\"\npersist = true\nmem_limit = \"256m\"\ncpu_percent = 50\n</code></pre> <p>This file is managed automatically by pocketdock. It tracks container provenance and configuration for resumption and health checks.</p>"},{"location":"reference/configuration/#project-directory-structure","title":"Project Directory Structure","text":"<pre><code>my-project/\n\u251c\u2500\u2500 .pocketdock/\n\u2502   \u251c\u2500\u2500 pocketdock.yaml          # Project configuration\n\u2502   \u2514\u2500\u2500 instances/\n\u2502       \u2514\u2500\u2500 my-sandbox/\n\u2502           \u251c\u2500\u2500 instance.toml     # Container metadata\n\u2502           \u251c\u2500\u2500 history.jsonl     # Command history\n\u2502           \u2514\u2500\u2500 logs/             # Session and detach logs\n\u2514\u2500\u2500 ... (your code)\n</code></pre>"},{"location":"reference/errors/","title":"Error Reference","text":"<p>All exceptions inherit from <code>PocketDockError</code> and can be imported from <code>pocketdock</code>.</p>"},{"location":"reference/errors/#hierarchy","title":"Hierarchy","text":"<pre><code>PocketDockError\n\u251c\u2500\u2500 SocketError\n\u2502   \u251c\u2500\u2500 SocketConnectionError\n\u2502   \u251c\u2500\u2500 SocketCommunicationError\n\u2502   \u2514\u2500\u2500 PodmanNotRunning\n\u251c\u2500\u2500 ContainerError\n\u2502   \u251c\u2500\u2500 ContainerNotFound\n\u2502   \u251c\u2500\u2500 ContainerNotRunning\n\u2502   \u2514\u2500\u2500 ContainerGone\n\u251c\u2500\u2500 ImageNotFound\n\u251c\u2500\u2500 SessionClosed\n\u2514\u2500\u2500 ProjectNotInitialized\n</code></pre>"},{"location":"reference/errors/#base-exception","title":"Base Exception","text":""},{"location":"reference/errors/#pocketdockerror","title":"<code>PocketDockError</code>","text":"<p>Base exception for all pocketdock errors. Catch this to handle any pocketdock error:</p> <pre><code>from pocketdock import PocketDockError\n\ntry:\n    c = create_new_container()\nexcept PocketDockError as e:\n    print(f\"pocketdock error: {e}\")\n</code></pre>"},{"location":"reference/errors/#socket-errors","title":"Socket Errors","text":"<p>Raised when there are issues connecting to or communicating with the container engine.</p>"},{"location":"reference/errors/#socketerror","title":"<code>SocketError</code>","text":"<p>Base class for all socket-related errors.</p>"},{"location":"reference/errors/#socketconnectionerror","title":"<code>SocketConnectionError</code>","text":"<p>Cannot connect to the container engine socket.</p> Attribute Type Description <code>socket_path</code> <code>str</code> Path to the socket that failed <code>detail</code> <code>str</code> Additional error details <p>When raised: The socket file doesn't exist, permission denied, or the engine isn't running.</p> <pre><code>from pocketdock import SocketConnectionError\n\ntry:\n    c = create_new_container()\nexcept SocketConnectionError as e:\n    print(f\"Can't connect to {e.socket_path}: {e.detail}\")\n</code></pre>"},{"location":"reference/errors/#socketcommunicationerror","title":"<code>SocketCommunicationError</code>","text":"<p>Error during communication over the socket.</p> Attribute Type Description <code>detail</code> <code>str</code> Error details <p>When raised: Unexpected response, malformed data, or connection dropped during an operation.</p>"},{"location":"reference/errors/#podmannotrunning","title":"<code>PodmanNotRunning</code>","text":"<p>No container engine socket found.</p> <p>When raised: Auto-detection checked all known socket paths and none were available.</p>"},{"location":"reference/errors/#container-errors","title":"Container Errors","text":"<p>Raised when there are issues with a specific container.</p>"},{"location":"reference/errors/#containererror","title":"<code>ContainerError</code>","text":"<p>Base class for container-related errors.</p> Attribute Type Description <code>container_id</code> <code>str</code> Container ID or name <code>detail</code> <code>str</code> Additional error details"},{"location":"reference/errors/#containernotfound","title":"<code>ContainerNotFound</code>","text":"<p>Container does not exist.</p> Attribute Type Description <code>container_id</code> <code>str</code> Container ID or name <p>When raised: The engine returned a 404 for the container ID. The container was never created, or it was already removed.</p> <pre><code>from pocketdock import ContainerNotFound\n\ntry:\n    c = resume_container(\"nonexistent\")\nexcept ContainerNotFound as e:\n    print(f\"Container not found: {e.container_id}\")\n</code></pre>"},{"location":"reference/errors/#containernotrunning","title":"<code>ContainerNotRunning</code>","text":"<p>Container exists but is not running.</p> Attribute Type Description <code>container_id</code> <code>str</code> Container ID or name <p>When raised: An operation that requires a running container (e.g., <code>run()</code>, <code>session()</code>) was called on a stopped container.</p>"},{"location":"reference/errors/#containergone","title":"<code>ContainerGone</code>","text":"<p>Container was removed externally.</p> Attribute Type Description <code>container_id</code> <code>str</code> Container ID or name <p>When raised: The container existed when pocketdock last checked, but it's gone now. Likely removed by another process or the engine.</p>"},{"location":"reference/errors/#image-errors","title":"Image Errors","text":""},{"location":"reference/errors/#imagenotfound","title":"<code>ImageNotFound</code>","text":"<p>Requested image does not exist locally.</p> Attribute Type Description <code>image</code> <code>str</code> Image tag <p>When raised: <code>create_new_container()</code> was called with an image that hasn't been built or pulled.</p> <pre><code>from pocketdock import ImageNotFound\n\ntry:\n    c = create_new_container(image=\"nonexistent:latest\")\nexcept ImageNotFound as e:\n    print(f\"Image not found: {e.image}\")\n</code></pre>"},{"location":"reference/errors/#session-errors","title":"Session Errors","text":""},{"location":"reference/errors/#sessionclosed","title":"<code>SessionClosed</code>","text":"<p>Operation attempted on a closed session.</p> <p>When raised: <code>send()</code>, <code>send_and_wait()</code>, or <code>read()</code> was called after <code>close()</code>.</p> <pre><code>from pocketdock import SessionClosed\n\nsess = c.session()\nsess.close()\ntry:\n    sess.send(\"echo hello\")\nexcept SessionClosed:\n    print(\"Session is closed\")\n</code></pre>"},{"location":"reference/errors/#project-errors","title":"Project Errors","text":""},{"location":"reference/errors/#projectnotinitialized","title":"<code>ProjectNotInitialized</code>","text":"<p>Operation requires a project directory that doesn't exist.</p> <p>When raised: <code>doctor()</code> or project-related operations were called outside a <code>.pocketdock/</code> project directory.</p> <pre><code>from pocketdock import ProjectNotInitialized\n\ntry:\n    report = doctor()\nexcept ProjectNotInitialized:\n    print(\"Run init_project() first\")\n</code></pre>"},{"location":"reference/types/","title":"Types Reference","text":"<p>All types are frozen dataclasses importable from <code>pocketdock</code>.</p>"},{"location":"reference/types/#execresult","title":"ExecResult","text":"<p>Result of a command execution.</p> <pre><code>from pocketdock import ExecResult\n</code></pre> Field Type Default Description <code>exit_code</code> <code>int</code> \u2014 Process exit code <code>stdout</code> <code>str</code> <code>\"\"</code> Standard output <code>stderr</code> <code>str</code> <code>\"\"</code> Standard error <code>duration_ms</code> <code>float</code> <code>0.0</code> Execution time in milliseconds <code>timed_out</code> <code>bool</code> <code>False</code> Whether the command timed out <code>truncated</code> <code>bool</code> <code>False</code> Whether output was truncated"},{"location":"reference/types/#properties","title":"Properties","text":"Property Type Description <code>ok</code> <code>bool</code> <code>True</code> if <code>exit_code == 0</code> and not <code>timed_out</code> <pre><code>result = c.run(\"echo hello\")\nresult.ok           # True\nresult.exit_code    # 0\nresult.stdout       # \"hello\\n\"\nresult.duration_ms  # 47.2\n</code></pre>"},{"location":"reference/types/#containerinfo","title":"ContainerInfo","text":"<p>Live snapshot of a container's state.</p> <pre><code>info = c.info()\n</code></pre> Field Type Default Description <code>id</code> <code>str</code> \u2014 Container ID <code>name</code> <code>str</code> \u2014 Container name <code>status</code> <code>str</code> \u2014 <code>\"running\"</code>, <code>\"exited\"</code>, etc. <code>image</code> <code>str</code> \u2014 Image tag <code>created_at</code> <code>datetime.datetime</code> \u2014 Creation timestamp <code>started_at</code> <code>datetime.datetime \\| None</code> <code>None</code> Start timestamp <code>uptime</code> <code>datetime.timedelta \\| None</code> <code>None</code> Time since started <code>memory_usage</code> <code>str</code> <code>\"\"</code> Human-readable memory usage (e.g., <code>\"42.1 MB\"</code>) <code>memory_limit</code> <code>str</code> <code>\"\"</code> Human-readable memory limit (e.g., <code>\"256 MB\"</code>) <code>memory_percent</code> <code>float</code> <code>0.0</code> Memory usage as percentage <code>cpu_percent</code> <code>float</code> <code>0.0</code> CPU usage as percentage <code>pids</code> <code>int</code> <code>0</code> Number of running processes <code>network</code> <code>bool</code> <code>False</code> Whether networking is enabled <code>ip_address</code> <code>str</code> <code>\"\"</code> Container IP address <code>processes</code> <code>tuple[dict[str, str], ...]</code> <code>()</code> Running processes"},{"location":"reference/types/#containerlistitem","title":"ContainerListItem","text":"<p>Summary of a container from <code>list_containers()</code>.</p> <pre><code>from pocketdock import list_containers\n\nitems = list_containers()\n</code></pre> Field Type Default Description <code>id</code> <code>str</code> \u2014 Container ID <code>name</code> <code>str</code> \u2014 Container name <code>status</code> <code>str</code> \u2014 <code>\"running\"</code> or <code>\"exited\"</code> <code>image</code> <code>str</code> \u2014 Image tag <code>created_at</code> <code>str</code> \u2014 ISO creation timestamp <code>persist</code> <code>bool</code> \u2014 Whether container is persistent <code>project</code> <code>str</code> <code>\"\"</code> Associated project name"},{"location":"reference/types/#streamchunk","title":"StreamChunk","text":"<p>A chunk of output from a streaming command.</p> <pre><code>for chunk in c.run(\"make all\", stream=True):\n    print(f\"[{chunk.stream}] {chunk.data}\", end=\"\")\n</code></pre> Field Type Description <code>stream</code> <code>str</code> <code>\"stdout\"</code> or <code>\"stderr\"</code> <code>data</code> <code>str</code> Text content"},{"location":"reference/types/#buffersnapshot","title":"BufferSnapshot","text":"<p>Snapshot of a detached process's ring buffer.</p> <pre><code>proc = c.run(\"python server.py\", detach=True)\noutput = proc.peek()\n</code></pre> Field Type Description <code>stdout</code> <code>str</code> Buffered stdout content <code>stderr</code> <code>str</code> Buffered stderr content"},{"location":"reference/types/#doctorreport","title":"DoctorReport","text":"<p>Result of <code>doctor()</code> health check.</p> <pre><code>from pocketdock import doctor\n\nreport = doctor()\n</code></pre> Field Type Description <code>orphaned_containers</code> <code>tuple[str, ...]</code> Container names without matching instance dirs <code>stale_instance_dirs</code> <code>tuple[str, ...]</code> Instance dir names without matching containers <code>healthy</code> <code>int</code> Count of healthy container-dir pairs"},{"location":"reference/types/#profileinfo","title":"ProfileInfo","text":"<p>Metadata about an image profile.</p> <pre><code>from pocketdock import resolve_profile\n\ninfo = resolve_profile(\"minimal\")\n</code></pre> Field Type Description <code>name</code> <code>str</code> Profile name <code>image_tag</code> <code>str</code> Docker/Podman image tag <code>dockerfile_dir</code> <code>str</code> Path to Dockerfile directory <code>network_default</code> <code>bool</code> Default network setting <code>description</code> <code>str</code> Human-readable description <code>size_estimate</code> <code>str</code> Approximate image size"}]}